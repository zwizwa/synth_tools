Distill some ideas.  Basically, start from types this time.

replace combinator functions by combinator macros
-------------------------------------------------

This is _the_ main point.

A program is an application of a set of combinators that lift
primitive operations over more complex data types.  Let's assume that
everything fits this picture.

To perform efficient compilation of combinators, they should be
inlined such that control and data indirection can be removed by the
low level compiler (C or LLVM).

So the compilation decisions are about which combinators to inline,
and which to implement using some kind of control flow indirection
(code parameterization and re-use).

Can I make this explicit?

Start by making this into a notation: the programmer will explicitly
indicate whether a combinator is implemented as a target function or
is inlined and eliminated at compile time.



representative example
----------------------

The combinator to focus on is parameter interpolation.  E.g. suppose
there is control rate gain amount and audio rate base signal.  The
combinator will apply the interpolator (to be specified) and produce a
single base rate signal.



main question
-------------

Is it enough to do this as C inline functions?

The answer is yes for straight-line DSP, but no for blocking code.
Performing "causalisation" will have to happen in a different way.
Maybe it will fall out after doing everything type-driven?



type encoding
-------------

The problem I had in final tagless Haskell embedding before is that
signal flow code is pure, but the Haskell embedding drags around that
representation monad.

A combinator approach would solve this, but the _interpretation of_
the description of a top level processor would still need some kind of
state tracking to implement / name the signal nodes.

So how do those 2 mix?

Basically, it needs an interpreter to decouple things. The interpreter
could operate on a data structure that includes reified type
information, which are generated by typed wrappers.

This makes one pattern clear: at the level of signals, the DSL is
stateless, but at individual instances of time and space, it helps to
have some context.






